# JVM 概述

Java Virtual Machine ，Java 程序的**运行环境（Java 二进制字节码的运行环境）**

#### JVM、JRE、JDK的关系

<img src="/Users/kevin/Documents/MyCode/jvm_prac/img/截屏2022-09-01 11.09.33.png" alt="截屏2022-09-01 11.09.33" style="zoom:20%;" />

JVM的学习路线，也是java程序运行到的流程

<img src="/Users/kevin/Documents/MyCode/jvm_prac/img/截屏2022-09-01 11.10.59.png" alt="截屏2022-09-01 11.10.59" style="zoom:30%;" />

**ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。**
**Method Area：类是放在方法区中。**
**Heap：类的实例对象。**
**当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。**
**方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口。**

# 内存结构

## 程序计数器（内存区域）

Program Counter Register 程序计数器（寄存器）
作用：是记录下一条 jvm 指令的执行地址行号。

执行native本地方法时，程序计数器的值为空（Undefined）。

**程序计数器的值为对应线程执行字节码指令的地址**。程序计数器只是改变所记录的地址，并不会申请新的内存空间，所以程序计数器的内存空间一旦分配，是不会发生改变的，因此也不存在内存溢出。

**jvm指令（实例如下）并不是机器码，jvm指令还要经过解释器变成机器码**

```java
0: getstatic #20 // PrintStream out = System.out; 
3: astore_1 // -- 
4: aload_1 // out.println(1); 
5: iconst_1 // -- 
6: invokevirtual #26 // -- 
9: aload_1 // out.println(2); 
10: iconst_2 // -- 
11: invokevirtual #26 // -- 
14: aload_1 // out.println(3); 
15: iconst_3 // -- 
16: invokevirtual #26 // -- 
19: aload_1 // out.println(4); 
20: iconst_4 // -- 
21: invokevirtual #26 // -- 
24: aload_1 // out.println(5); 
25: iconst_5 // -- 
26: invokevirtual #26 // -- 
29: return
```

特点：

- 是线程私有的
- 不会存在内存溢出（所在的区域不会发生内存溢出）

- 解释器会解释指令为机器码交给 cpu 执行，**程序计数器会记录下一条指令的地址行号**，这样**下一次解释器会从程序计数器拿到指令**然后进行解释执行。

- 多线程的环境下，如果两个线程发生了上下文切换，那么程序计数器会记录线程下一行指令的地址行号，以便于接着往下执行。

## 虚拟机栈（内存空间）

- 每个线程运行需要的内存空间，称为虚拟机栈
- 每个栈由多个栈帧（Frame）组成，对应着每次调用方法时所占用的内存（**局部变量**）
- 每个线程只能有一个活动栈帧，对应着当前正在执行的方法

栈内存是方法调用产生的，方法调用结束后会弹出栈，所以不涉及垃圾回收

栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。

栈帧过大、过多、或者第三方类库操作，都有可能造成栈内存溢出 java.lang.stackOverflowError 。

使用 -Xss256k 指定栈内存大小

如果是局部变量引用了对象，并逃离了方法的访问，那就要考虑线程安全问题

## 本地方法栈

一些带有 native 关键字的方法就是需要 JAVA 去调用本地的C或者C++方法，因为 JAVA 有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带 native 关键字的方法。

## 堆

- 通过new关键字创建的对象都会被放在堆内存
- 它是线程共享，堆内存中的对象都需要考虑线程安全问题
- 有垃圾回收机制

## 堆内存和虚拟机栈内存的区别

1、堆内存一直扩大对象的size可以撑爆堆内存，一直递归调用方法叠加栈帧可以撑爆栈内存，但这都是表面现象

2、但其实本质是，首先明确，new是申请任意大小的内存，new 完之后，对象放在堆内存中，同时方法中对象名字就是一个指针，指向了堆内存中的对象。方法中对象的名字（指针）占用了栈内存，真实的对象占用了堆内存。所以堆是所有线程共享的，但是这个指针不是所有线程共享的。

## 找不到批量制造局部变量的原因（局部变量表）

1、局部变量表也被称之为局部变量数组或本地变量表

2、局部变量表**定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**,这些数据类型包括各类基本数据类型、对象引用(reference），以及returnAddress类型。

3、由于局部变量表是建立在线程的栈上，是线程的私有数据，因此**不存在数据安全问题**

4、**局部变量表所需的容量大小是在编译期确定下来的**，并保存在方法的**Code属性**的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。每一个方法运行的时候都是一个栈帧，因此我认为**局部变量表是体现在一个个栈帧上的**。可以看到第六条，当栈帧销毁的时候，局部变量表也会销毁

5、**方法嵌套调用的次数由栈的大小决定。**一般来说，**栈越大，方法嵌套调用次数越多。**对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的**栈帧就越大**，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。

6、**局部变量表中的变量只在当前方法调用中有效**。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。**

## 方法区

它用来存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括特殊方法（用于类和实例初始化以及接口初始化方法）。

方法区是在虚拟机启动时创建的，逻辑上时堆的一部分，但是不同的jvm厂商可以有不同的实现。比如hostpot虚拟机，在**jkd1.8之前叫做永久代，使用的是堆的内存，1.8之后叫做元空间，使用的是操作系统的内存**

<img src="/Users/kevin/Documents/MyCode/jvm_prac/img/截屏2022-09-10 16.51.20.png" alt="截屏2022-09-10 16.51.20" style="zoom:50%;" />

这是1.8之前的，class就是存储类的信息，classloader就是类加载器<img src="/Users/kevin/Documents/MyCode/jvm_prac/img/截屏2022-09-10 16.52.55.png" alt="截屏2022-09-10 16.52.55" style="zoom:50%;" />

**1.8之后虽然变了，但是String Table还是留在了堆中**。因为用的是系统内存，所以发生溢出就要看系统内存的大小。可以通过设置虚拟机参数区测试方法区的溢出问题

- 1.8 之前会导致永久代内存溢出

   使用 -XX:MaxPermSize=8m 指定永久代内存大小

- 1.8 之后会导致元空间内存溢出

   使用 -XX:MaxMetaspaceSize=8m 指定元空间大小

  **图片里面其实是运行时常量池**，运行时常量池记录着地址，连接着class里面的各种类的具体东西。

### 常量池

常量池表中的地址可能对应着一个类名、方法名、参数类型等信息。具体信息看代码

### 运行时常量池

刚才分析的常量池是我们通过反编译.class文件看到的表。当该类被加载以后，它的常量池信息就会放入运行时常量池，并**把里面的符号地址（#1啥的）变为真实地址（放到内存里面的真实地址）**。**方法的代码、类的信息什么的会存到class中去**

### StringTable

本质就是一个hashtable，不能够扩容

常量池中的信息，都会被加载到运行时常量池，字符串原本就是常量池中的符号。当执行代码String s = “a"的时候，才会转换成字符串对象。转换完成后，把字符串对象存入StringTable中。

通过 String = `"xxx"`这种形式，以**字符串字面量**的形式会创建出一个String对象，而**以字符串字面量创建的对象都是会进入到一个叫做StringTable**（字符串常量池，串池）的地方。以其他方式创建出来的对象，比如通过new关键字，又或者是通过StringBuilder的append方法后再toString，这样创建出来的字符串对象是不会进入StringTable的，如果想让字符串进入串池，那么就得调用String类的intern()方法

String str = new String("hello"); 会创建出来**一个或两个对象**

若在执行该行代码之前，就已经有过字符串字面量"hello"的出现，那么StringTable当中就会有"hello"存在，下一次需要使用时，就会直接从StringTable中获取而不是再次创建对象。而new String("hello");这个操作是一定会通过new这个关键字而创建出对象的，这时仅仅只是创建了一个对象存放在堆空间中，并把内存地址引用给str变量。

相反，若在执行该行代码之前没有出现过"hello"的出现，执行到该行代码时是"hello"的第一次出现，那么就需要创建两个对象，一**个是字符串字面量的对象会放入StringTable中，另一个就是通过new关键字创建出来的对象，放入堆空间中**。经验证雀食是这样

String s = "a" + "b";就会直接找串池中的“ab”，**javac在编译器优化了代码**，因为a + b的结果是确定的，所以才会直接找串池中的对象

**StringTable里面也会发生垃圾回收**

#### StringTable调优

- 因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间
- -XX:StringTableSize=桶个数（最少设置为 1009 以上）
- 考虑是否需要将字符串对象入池，如果有大量的重复字符对象，可以通过 intern 方法减少重复入池，减少对中的字符串对象

## 直接内存

### 普通文件的读取流程

java 不能直接操作文件管理，需要**切换到内核态**，**使用本地方法进行操作**，然后读取磁盘文件，会在系统内存中创建一个缓冲区，将数据读到系统缓冲区， 然后在将系统缓冲区数据，**复制到 java 堆内存中。缺点是数据存储了两份，在系统内存中有一份，java 堆中有一份，造成了不必要的复制**。

<img src="/Users/kevin/Documents/MyCode/jvm_prac/img/20210208180041113.png" alt="20210208180041113" style="zoom:50%;" />

**直接内存是操作系统和 Java 代码都可以访问的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率。**

<img src="/Users/kevin/Documents/MyCode/jvm_prac/img/20210208181022863.png" alt="20210208181022863" style="zoom:50%;" />

# 垃圾回收

## 判断对象是否可以回收

### 引用计数法

引用计数法在对象头中添加了一个计数器来记录对象的被引用数，被引用时，就当引用对象的值加一。当某个对象的引用计数减为0时，**collector需要递归遍历它所指向的所有域**，将它所有域所指向的对象的引用计数都减一，然后才能回收当前对象。

![aHR0cDovL3d3dy5wcm9jZXNzb24uY29tL2NoYXJ0X2ltYWdlLzUzMDljZWZjMGNmMjYyYjU1OWY4ZDA0MC5wbmc](/Users/kevin/Documents/MyCode/jvm_prac/img/aHR0cDovL3d3dy5wcm9jZXNzb24uY29tL2NoYXJ0X2ltYWdlLzUzMDljZWZjMGNmMjYyYjU1OWY4ZDA0MC5wbmc.png)

连个相互引用的对象在方法中其实已经没有被引用了，只有他俩**对象内的指针在堆中互相引用**，根本没有外部的指针引用他俩，就是两个垃圾，但是无法清除

### 可达性分析算法

- JVM 中的垃圾回收器通过可达性分析来探索所有存活的对象
- 扫描堆中的对象，看能否沿着 GC Root 对象为起点的引用链找到该对象，如果找不到，则表示可以回收

* 可以作为 GC Root 的对象（为了针对引用计数法中只有堆中指针引用，无方法指针引用的情况）
  * 虚拟机栈（栈帧中的本地变量表）中引用的对象。
  * 方法区中类静态属性引用的对象
  * 方法区中常量引用的对象（final修饰）
  * 本地方法栈中 JNI（即一般说的Native方法）引用的对象

### 四种（第五种了解就行）引用

![20210209113952135](/Users/kevin/Documents/MyCode/jvm_prac/img/20210209113952135.png)

* 强引用：只要是正经创建的对象变量名，那都是强引用对象。只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收。只要是这个对象还有强引用，**就算是出现了OOM也不会对该对象进行回收**。
* 软引用：弱引用相当于堆中的对象被一种特殊的变量指针引用了（弱引用指针），当然对象也会有正常的变量指针引用，这些都还是强引用。当仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会**再次出发垃圾回收**，回收软引用对象。**可以配合引用队列**来释放软引用自身，引用队列就是一个队列，当软引用变量指针的对象断开后放入引用队列，引用队列有不同的函数定期来清理他们要清理的指针。软引用这个特殊的变量指针实现的时候也是创建对象实现
* 弱引用：仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象，**可以配合引用队列**来释放弱引用自身。实现方式和软引用相同
* 虚引用：必须配合引用队列使用。主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存。当使用直接内存时，jvm并不能管理直接内存，所以直接内存的工具类对象就是一个虚引用的特殊指针，当被虚引用的指针对象被断开后，就将指针对象放入引用对象，jvm清理时使用工具类对象中的clean方法，估计是本地方法，可以直接操作系统的内存
* 终结器引用：无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，**第二次 GC 时才能回收被引用对象**。不推荐使用该方法，处理线程的优先级很低